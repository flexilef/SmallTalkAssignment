Object subclass: #BinTree	instanceVariableNames: 'rootLabel leftKid rightKid'	classVariableNames: ''	poolDictionaries: ''	category: 'TraversableTree'!!BinTree methodsFor: 'setters' stamp: 'KF 3/3/2017 16:34'!addLeftKid: tree	"sets left subtree"	leftKid _ tree! !!BinTree methodsFor: 'setters' stamp: 'KF 3/3/2017 16:34'!addRightKid: tree	"sets right subtree"	rightKid _ tree! !!BinTree methodsFor: 'setters' stamp: 'FL 3/4/2017 15:25'!setRoot: tree	"comment stating purpose of message"	rootLabel _ tree.! !!BinTree methodsFor: 'getters' stamp: 'KF 3/3/2017 16:30'!leftKid	"return the left subtree"	^leftKid! !!BinTree methodsFor: 'getters' stamp: 'KF 3/3/2017 16:42'!rightKid	"return the right subtree"	^rightKid! !!BinTree methodsFor: 'getters' stamp: 'FL 3/4/2017 17:29'!rootLabel	"return the label of the root node"		^rootLabel! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BinTree class	instanceVariableNames: 'rootLabel leftKid rightKid'!!BinTree class methodsFor: 'Creation' stamp: 'FL 3/4/2017 16:12'!newRoot: root	"Creates a new instance of BinTree with a single node"	| instance |	instance := super new.	instance setRoot: root.	^instance! !Object subclass: #InorderTraversal	instanceVariableNames: 'rootNode currentNode visitStack'	classVariableNames: ''	poolDictionaries: ''	category: 'TraversableTree'!!InorderTraversal methodsFor: 'getters' stamp: 'FL 3/4/2017 16:34'!getCurrentNode	"comment stating purpose of message"		^currentNode! !!InorderTraversal methodsFor: 'getters' stamp: 'FL 3/4/2017 16:46'!getRoot	"comment stating purpose of message"		^rootNode! !!InorderTraversal methodsFor: 'getters' stamp: 'FL 3/4/2017 22:10'!getVisitStack	"returns the stack of visited nodes"		^visitStack! !!InorderTraversal methodsFor: 'setters' stamp: 'FL 3/4/2017 17:10'!setCurrentNode: node	"comment stating purpose of message"		currentNode _ node.! !!InorderTraversal methodsFor: 'setters' stamp: 'FL 3/4/2017 16:46'!setRoot: root	"comment stating purpose of message"		rootNode _ root.! !!InorderTraversal methodsFor: 'Traversal' stamp: 'FL 3/4/2017 17:29'!first	"Returns the first/root node"		^rootNode! !!InorderTraversal methodsFor: 'Traversal' stamp: 'FL 3/5/2017 13:30'!next	"gets the next tree node based on inorder traversal"	| nextNode |	nextNode := currentNode.		"check if entire tree has been searched"	(currentNode isNil) ifTrue: [^nil].		"if current node is a leaf, return it"	(self isLeaf: currentNode) ifTrue: [		(visitStack isEmpty) ifTrue: [			currentNode := nil.		]		ifFalse: [			currentNode := visitStack top.		].			^nextNode	].	"if current node is a visited parent node, return it"	(visitStack isEmpty not) 		ifTrue: [ 			(currentNode == visitStack top) ifTrue: [						visitStack pop.				"make sure there is a right subtree to search or else go back to parent"				(currentNode rightKid isNil not) 					ifTrue: [						currentNode := currentNode rightKid.					]					ifFalse: [						(visitStack isEmpty not) 							ifTrue: [								currentNode := visitStack top.							]							"we found last leaf"							ifFalse: [								currentNode := nil.							].					].								^nextNode.			]		].			"store visited node"	visitStack push: nextNode.	"get the leftest most node"	[nextNode leftKid isNil not] whileTrue: [ nextNode := nextNode leftKid. visitStack push: nextNode].		"if is leaf, return it"	(self isLeaf: nextNode)		ifTrue: [			visitStack pop. "pop off the node to be returned"			currentNode := visitStack top. "start next search at the parent"			^nextNode.		]		ifFalse: [			"check if has right subtree"			(nextNode rightKid isNil not) ifTrue: [				currentNode := nextNode rightKid.			].						visitStack pop.			^nextNode.		].			! !!InorderTraversal methodsFor: 'Traversal' stamp: 'FL 3/4/2017 18:58'!traverse: node	"traverses down a node's children"	| isLeaf nextNode |	isLeaf := (node leftKid isNil) & ( node rightKid isNil).	isLeaf 		ifTrue: [nextNode := nil]		ifFalse: [		"check left kid"		(node leftKid isNil not) 			ifTrue: [self traverse: node leftKid].		"check right kid"		(node rightKid isNil not)			ifTrue: [nextNode := node rightKid].		].		^nextNode! !!InorderTraversal methodsFor: 'helper' stamp: 'FL 3/4/2017 21:51'!getLeftestLeaf: node	"returns the left most node"	| leftestNode nextNode|	[node isNil] ifTrue: [^nil].	nextNode := node.	"traverse until we find the leftest most leaf"	[nextNode leftKid isNil not] WhileTrue: [ nextNode := nextNode leftKid].	leftestNode := nextNode.		^leftestNode	! !!InorderTraversal methodsFor: 'helper' stamp: 'FL 3/4/2017 22:39'!init	"initializes the visit stack"		visitStack := Stack new.! !!InorderTraversal methodsFor: 'helper' stamp: 'FL 3/4/2017 21:30'!isLeaf: node	"checks if the node is a leaf"	| isLeaf |		(node isNil) ifTrue: [^nil].		isLeaf := (node leftKid isNil) & ( node rightKid isNil).		^isLeaf! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InorderTraversal class	instanceVariableNames: ''!!InorderTraversal class methodsFor: 'Creation' stamp: 'FL 3/4/2017 22:19'!newTraversal: root	"comment stating purpose of message"	| instance |	instance := super new.	instance setRoot: root.	instance setCurrentNode: root.	instance init.	^ instance! !