Object subclass: #BinTree	instanceVariableNames: 'rootLabel leftKid rightKid'	classVariableNames: ''	poolDictionaries: ''	category: 'TraversableTree'!!BinTree methodsFor: 'setters' stamp: 'KF 3/3/2017 16:34'!addLeftKid: tree	"sets left subtree"	leftKid _ tree! !!BinTree methodsFor: 'setters' stamp: 'KF 3/3/2017 16:34'!addRightKid: tree	"sets right subtree"	rightKid _ tree! !!BinTree methodsFor: 'setters' stamp: 'KF 3/6/2017 15:45'!setRoot: label	"set root node label"	rootLabel _ label.! !!BinTree methodsFor: 'getters' stamp: 'KF 3/3/2017 16:30'!leftKid	"return the left subtree"	^leftKid! !!BinTree methodsFor: 'getters' stamp: 'KF 3/3/2017 16:42'!rightKid	"return the right subtree"	^rightKid! !!BinTree methodsFor: 'getters' stamp: 'FL 3/4/2017 17:29'!rootLabel	"return the label of the root node"		^rootLabel! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BinTree class	instanceVariableNames: 'rootLabel leftKid rightKid'!!BinTree class methodsFor: 'Creation' stamp: 'KF 3/6/2017 15:42'!new: root	"Creates a new instance of BinTree with a single node"	| instance |	instance := super new.	instance setRoot: root.	^instance! !Object subclass: #InorderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraversableTree'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InorderTest class	instanceVariableNames: ''!!InorderTest class methodsFor: 'testScripts' stamp: 'KF 3/8/2017 10:59'!testIterative	"test method for inorder traversal of BinTree via iteration"	"README: to call this method, type 'InorderTest testIterative' into workspace" 	|node1 node2 node3 node4 node5 node6 node7 node8 node9 node10 traverse nextLabel|		Transcript clear.		" Test tree #1" 	Transcript show: '------------- TREE #1 (complete, depth=3)--------------'; cr.	node1 _ BinTree new: 'A'.	node2 _ BinTree new: 'B'.	node3 _ BinTree new: 'C'.	node4 _ BinTree new: 'D'.	node5 _ BinTree new: 'E'.	node6 _ BinTree new: 'F'.	node7 _ BinTree new: 'G'.	node1 addLeftKid: node2.	node1 addRightKid: node3.	node2 addLeftKid: node4.	node2 addRightKid: node5.	node3 addLeftKid: node6.	node3 addRightKid: node7.	Transcript show: '     '.	Transcript show: node1 rootLabel; cr.	Transcript show: '    / ';  show:' \ '; cr.	Transcript show: '   '; show: node1 leftKid rootLabel; show: ' '.	Transcript show: '  '.	Transcript show: node1 rightKid rootLabel; cr.	Transcript show: ' / ';  show:' \ '; show: ' / ';  show:' \ '; cr.	Transcript show: node2 leftKid rootLabel.	Transcript show: '  '.	Transcript show: node2 rightKid rootLabel.	Transcript show: '  '.	Transcript show: node3 leftKid rootLabel.	Transcript show: '  '.	Transcript show: node3 rightKid rootLabel; cr.	Transcript show: '--------------- TRAVERSAL #1 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	nextLabel _ traverse first.	[nextLabel isNil not] whileTrue: [Transcript show: nextLabel rootLabel; cr. nextLabel _ traverse next ].		" Test tree #2" 	Transcript show: '------------- TREE #2 (skewed, depth=6)--------------'; cr.	node1 _ BinTree new: 'A'.	node2 _ BinTree new: 'B'.	node3 _ BinTree new: 'C'.	node4 _ BinTree new: 'D'.	node5 _ BinTree new: 'E'.	node6 _ BinTree new: 'F'.	node7 _ BinTree new: 'G'.	node1 addLeftKid: node2.	node1 addRightKid: node3.	node2 addLeftKid: node4.	node4 addLeftKid: node5.	node5 addRightKid: node6.	node6 addRightKid: node7.	Transcript show: '          '.	Transcript show: node1 rootLabel; cr.	Transcript show: '         / ';  show:' \ '; cr.	Transcript show: '        '; show: node1 leftKid rootLabel; show: '  '.	Transcript show: node1 rightKid rootLabel; cr.	Transcript show: '       / '; cr.	Transcript show: '     '; show: node2 leftKid rootLabel; cr.	Transcript show: '    / '; cr.	Transcript show: '   '; show: node4 leftKid rootLabel; cr.	Transcript show: '     \ '; cr.	Transcript show: '       '; show: node5 rightKid rootLabel; cr.	Transcript show: '        \ '; cr.	Transcript show: '         '; show: node6 rightKid rootLabel; cr.	Transcript show: '--------------- TRAVERSAL #2 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	nextLabel _ traverse first.	[nextLabel isNil not] whileTrue: [Transcript show: nextLabel rootLabel; cr. nextLabel _ traverse next ].		"Test tree #3" 		Transcript show: '------------- TREE #3 (skewed, depth=6)--------------'; cr.		node1 _ BinTree new: 'L'.	node2 _ BinTree new: 'E'.	node3 _ BinTree new: 'H'.	node4 _ BinTree new: 'L'.	node5 _ BinTree new: 'D'.	node6 _ BinTree new: 'O'.	node7 _ BinTree new: 'O'.	node8 _ BinTree new: 'W'.	node9 _ BinTree new: 'R'.	node10 _ BinTree new: 'L'.		node1 addLeftKid: node2.	node2 addLeftKid: node3.	node2 addRightKid: node4.	node1 addRightKid: node5.	node5 addLeftKid: node6.	node6 addRightKid: node7.	node7 addLeftKid: node8.	node7 addRightKid: node9.	node9 addRightKid: node10.		Transcript show: '            '.	Transcript show: node1 rootLabel;cr.	Transcript show: '          /   \'; cr.	Transcript show: '         '.	Transcript show: node2 rootLabel.	Transcript show: '    '.	Transcript show: node5 rootLabel; cr.	Transcript show: '        /\    /'; cr.	Transcript show: '      '.	Transcript show: node3 rootLabel.	Transcript show: '  '.	Transcript show: node4 rootLabel.	Transcript show: ' '.	Transcript show: node6 rootLabel; cr.	Transcript show: '               \'; cr.	Transcript show: '                '.	Transcript show: node7 rootLabel; cr.	Transcript show: '                /\'; cr.	Transcript show: '              '.	Transcript show: node8 rootLabel.	Transcript show: ' '.	Transcript show: node9 rootLabel;cr.	Transcript show: '                    \'; cr.	Transcript show: '                      '.	Transcript show: node10 rootLabel;cr.		Transcript show: '--------------- TRAVERSAL #3 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	nextLabel _ traverse first.	[nextLabel isNil not] whileTrue: [Transcript show: nextLabel rootLabel; cr. nextLabel _ traverse next ].	! !!InorderTest class methodsFor: 'testScripts' stamp: 'KF 3/8/2017 10:57'!testRecursive	"test method for inorder traversal of BinTree via recursion"	"README: to call this method, type 'InorderTest testRecursive' into workspace" 	|node1 node2 node3 node4 node5 node6 node7 node8 node9 node10 traverse|		Transcript clear.		" Test tree #1" 	Transcript show: '------------- TREE #1 (complete, depth=3)--------------'; cr.	node1 _ BinTree new: 'A'.	node2 _ BinTree new: 'B'.	node3 _ BinTree new: 'C'.	node4 _ BinTree new: 'D'.	node5 _ BinTree new: 'E'.	node6 _ BinTree new: 'F'.	node7 _ BinTree new: 'G'.	node1 addLeftKid: node2.	node1 addRightKid: node3.	node2 addLeftKid: node4.	node2 addRightKid: node5.	node3 addLeftKid: node6.	node3 addRightKid: node7.	Transcript show: '     '.	Transcript show: node1 rootLabel; cr.	Transcript show: '    / ';  show:' \ '; cr.	Transcript show: '   '; show: node1 leftKid rootLabel; show: ' '.	Transcript show: '  '.	Transcript show: node1 rightKid rootLabel; cr.	Transcript show: ' / ';  show:' \ '; show: ' / ';  show:' \ '; cr.	Transcript show: node2 leftKid rootLabel.	Transcript show: '  '.	Transcript show: node2 rightKid rootLabel.	Transcript show: '  '.	Transcript show: node3 leftKid rootLabel.	Transcript show: '  '.	Transcript show: node3 rightKid rootLabel; cr.	Transcript show: '--------------- TRAVERSAL #1 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	traverse traverseRecursively: node1.		" Test tree #2" 	Transcript show: '------------- TREE #2 (skewed, depth=6)--------------'; cr.	node1 _ BinTree new: 'A'.	node2 _ BinTree new: 'B'.	node3 _ BinTree new: 'C'.	node4 _ BinTree new: 'D'.	node5 _ BinTree new: 'E'.	node6 _ BinTree new: 'F'.	node7 _ BinTree new: 'G'.	node1 addLeftKid: node2.	node1 addRightKid: node3.	node2 addLeftKid: node4.	node4 addLeftKid: node5.	node5 addRightKid: node6.	node6 addRightKid: node7.	Transcript show: '          '.	Transcript show: node1 rootLabel; cr.	Transcript show: '         / ';  show:' \ '; cr.	Transcript show: '        '; show: node1 leftKid rootLabel; show: '  '.	Transcript show: node1 rightKid rootLabel; cr.	Transcript show: '       / '; cr.	Transcript show: '     '; show: node2 leftKid rootLabel; cr.	Transcript show: '    / '; cr.	Transcript show: '   '; show: node4 leftKid rootLabel; cr.	Transcript show: '     \ '; cr.	Transcript show: '       '; show: node5 rightKid rootLabel; cr.	Transcript show: '        \ '; cr.	Transcript show: '         '; show: node6 rightKid rootLabel; cr.	Transcript show: '--------------- TRAVERSAL #2 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	traverse traverseRecursively: node1.		" Test tree #3" 		Transcript show: '------------- TREE #3 (skewed, depth=6)--------------'; cr.		node1 _ BinTree new: 'L'.	node2 _ BinTree new: 'E'.	node3 _ BinTree new: 'H'.	node4 _ BinTree new: 'L'.	node5 _ BinTree new: 'D'.	node6 _ BinTree new: 'O'.	node7 _ BinTree new: 'O'.	node8 _ BinTree new: 'W'.	node9 _ BinTree new: 'R'.	node10 _ BinTree new: 'L'.		node1 addLeftKid: node2.	node2 addLeftKid: node3.	node2 addRightKid: node4.	node1 addRightKid: node5.	node5 addLeftKid: node6.	node6 addRightKid: node7.	node7 addLeftKid: node8.	node7 addRightKid: node9.	node9 addRightKid: node10.		Transcript show: '            '.	Transcript show: node1 rootLabel;cr.	Transcript show: '          /   \'; cr.	Transcript show: '         '.	Transcript show: node2 rootLabel.	Transcript show: '    '.	Transcript show: node5 rootLabel; cr.	Transcript show: '        /\    /'; cr.	Transcript show: '      '.	Transcript show: node3 rootLabel.	Transcript show: '  '.	Transcript show: node4 rootLabel.	Transcript show: ' '.	Transcript show: node6 rootLabel; cr.	Transcript show: '               \'; cr.	Transcript show: '                '.	Transcript show: node7 rootLabel; cr.	Transcript show: '                /\'; cr.	Transcript show: '              '.	Transcript show: node8 rootLabel.	Transcript show: ' '.	Transcript show: node9 rootLabel;cr.	Transcript show: '                    \'; cr.	Transcript show: '                      '.	Transcript show: node10 rootLabel;cr.		Transcript show: '--------------- TRAVERSAL #3 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	traverse traverseRecursively: node1.	! !Object subclass: #InorderTraversal	instanceVariableNames: 'rootNode currentNode visitStack'	classVariableNames: ''	poolDictionaries: ''	category: 'TraversableTree'!!InorderTraversal methodsFor: 'setters' stamp: 'FL 3/4/2017 17:10'!setCurrentNode: node	"comment stating purpose of message"		currentNode _ node.! !!InorderTraversal methodsFor: 'setters' stamp: 'FL 3/4/2017 16:46'!setRoot: root	"comment stating purpose of message"		rootNode _ root.! !!InorderTraversal methodsFor: 'IterativeTraversal' stamp: 'KF 3/8/2017 11:40'!first	"gets the first tree node based on inorder traversal"		| nextNode |	nextNode := currentNode.		"if root node is a leaf (i.e. a one node tree), return it"	(self isLeaf: currentNode) ifTrue: [		currentNode := nil.			^nextNode	].			"store visited node"	visitStack push: nextNode.	"get the leftest most node"	[nextNode leftKid isNil not] whileTrue: [ nextNode := nextNode leftKid. visitStack push: nextNode].		"if is leaf, return it"	(self isLeaf: nextNode)		ifTrue: [			visitStack pop. "pop off the node to be returned"			currentNode := visitStack top. "start next search at the parent"			^nextNode.		]		ifFalse: [			"check if has right subtree"			(nextNode rightKid isNil not) ifTrue: [				currentNode := nextNode rightKid.			].						visitStack pop.			^nextNode.		].! !!InorderTraversal methodsFor: 'IterativeTraversal' stamp: 'KF 3/7/2017 21:11'!next	"gets the next tree node based on inorder traversal"	| nextNode |	nextNode := currentNode.		"check if entire tree has been searched"	(currentNode isNil) ifTrue: [^nil].		"if current node is a leaf, return it"	(self isLeaf: currentNode) ifTrue: [		(visitStack isEmpty) ifTrue: [			currentNode := nil.		]		ifFalse: [			currentNode := visitStack top.		].			^nextNode	].	"if current node is a visited parent node, return it"	(visitStack isEmpty not) 		ifTrue: [ 			(currentNode == visitStack top) ifTrue: [						visitStack pop.				"make sure there is a right subtree to search or else go back to parent"				(currentNode rightKid isNil not) 					ifTrue: [						currentNode := currentNode rightKid.					]					ifFalse: [						(visitStack isEmpty not) 							ifTrue: [								currentNode := visitStack top.							]							"we found last leaf"							ifFalse: [								currentNode := nil.							].					].								^nextNode.			]		].			"store visited node"	visitStack push: nextNode.	"get the leftest most node"	[nextNode leftKid isNil not] whileTrue: [ nextNode := nextNode leftKid. visitStack push: nextNode].		"if is leaf, return it"	(self isLeaf: nextNode)		ifTrue: [			visitStack pop. "pop off the node to be returned"			currentNode := visitStack top. "start next search at the parent"			^nextNode.		]		ifFalse: [			"check if has right subtree"			(nextNode rightKid isNil not) ifTrue: [				currentNode := nextNode rightKid.			].						visitStack pop.			^nextNode.		].			! !!InorderTraversal methodsFor: 'helper' stamp: 'FL 3/4/2017 22:39'!init	"initializes the visit stack"		visitStack := Stack new.! !!InorderTraversal methodsFor: 'helper' stamp: 'FL 3/4/2017 21:30'!isLeaf: node	"checks if the node is a leaf"	| isLeaf |		(node isNil) ifTrue: [^nil].		isLeaf := (node leftKid isNil) & ( node rightKid isNil).		^isLeaf! !!InorderTraversal methodsFor: 'RecursiveTraversal' stamp: 'KF 3/6/2017 16:30'!traverseRecursively: tree	"the recursive way for inorder traversal"	| left right|	left _ tree leftKid.	right _ tree rightKid.		(left notNil) ifTrue: [ self traverseRecursively: left ].	Transcript show: tree rootLabel; cr.	(right notNil) ifTrue: [ self traverseRecursively: right ].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InorderTraversal class	instanceVariableNames: ''!!InorderTraversal class methodsFor: 'Creation' stamp: 'KF 3/6/2017 15:47'!new: root	"comment stating purpose of message"	| instance |	instance := super new.	instance setRoot: root.	instance setCurrentNode: root.	instance init.	^ instance! !