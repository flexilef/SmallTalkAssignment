Object subclass: #BinTree	instanceVariableNames: 'rootLabel leftKid rightKid'	classVariableNames: ''	poolDictionaries: ''	category: 'TraversableTree'!!BinTree methodsFor: 'setters' stamp: 'KF 3/3/2017 16:34'!addLeftKid: tree	"sets left subtree"	leftKid _ tree! !!BinTree methodsFor: 'setters' stamp: 'KF 3/3/2017 16:34'!addRightKid: tree	"sets right subtree"	rightKid _ tree! !!BinTree methodsFor: 'setters' stamp: 'KF 3/6/2017 15:45'!setRoot: label	"set root node label"	rootLabel _ label.! !!BinTree methodsFor: 'getters' stamp: 'KF 3/3/2017 16:30'!leftKid	"return the left subtree"	^leftKid! !!BinTree methodsFor: 'getters' stamp: 'KF 3/3/2017 16:42'!rightKid	"return the right subtree"	^rightKid! !!BinTree methodsFor: 'getters' stamp: 'FL 3/4/2017 17:29'!rootLabel	"return the label of the root node"		^rootLabel! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BinTree class	instanceVariableNames: 'rootLabel leftKid rightKid'!!BinTree class methodsFor: 'Creation' stamp: 'KF 3/6/2017 15:42'!new: root	"Creates a new instance of BinTree with a single node"	| instance |	instance := super new.	instance setRoot: root.	^instance! !Object subclass: #InorderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TraversableTree'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InorderTest class	instanceVariableNames: ''!!InorderTest class methodsFor: 'testScripts' stamp: 'KF 3/6/2017 17:06'!testIterative	"test method for inorder traversal of BinTree via iteration"	"README: to call this method, type 'InorderTest testIterative' into workspace" 	|node1 node2 node3 node4 node5 node6 node7 traverse|		Transcript clear.		" Test tree #1" 	Transcript show: '------------- TREE #1 (complete, depth=3)--------------'; cr.	node1 _ BinTree new: 'A'.	node2 _ BinTree new: 'B'.	node3 _ BinTree new: 'C'.	node4 _ BinTree new: 'D'.	node5 _ BinTree new: 'E'.	node6 _ BinTree new: 'F'.	node7 _ BinTree new: 'G'.	node1 addLeftKid: node2.	node1 addRightKid: node3.	node2 addLeftKid: node4.	node2 addRightKid: node5.	node3 addLeftKid: node6.	node3 addRightKid: node7.	Transcript show: '     '.	Transcript show: node1 rootLabel; cr.	Transcript show: '    / ';  show:' \ '; cr.	Transcript show: '   '; show: node1 leftKid rootLabel; show: ' '.	Transcript show: '  '.	Transcript show: node1 rightKid rootLabel; cr.	Transcript show: ' / ';  show:' \ '; show: ' / ';  show:' \ '; cr.	Transcript show: node2 leftKid rootLabel.	Transcript show: '  '.	Transcript show: node2 rightKid rootLabel.	Transcript show: '  '.	Transcript show: node3 leftKid rootLabel.	Transcript show: '  '.	Transcript show: node3 rightKid rootLabel; cr.	Transcript show: '--------------- TRAVERSAL #1 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr. 		" Test tree #2" 	Transcript show: '------------- TREE #2 (skewed, depth=6)--------------'; cr.	node1 _ BinTree new: 'A'.	node2 _ BinTree new: 'B'.	node3 _ BinTree new: 'C'.	node4 _ BinTree new: 'D'.	node5 _ BinTree new: 'E'.	node6 _ BinTree new: 'F'.	node7 _ BinTree new: 'G'.	node1 addLeftKid: node2.	node1 addRightKid: node3.	node2 addLeftKid: node4.	node4 addLeftKid: node5.	node5 addRightKid: node6.	node6 addRightKid: node7.	Transcript show: '          '.	Transcript show: node1 rootLabel; cr.	Transcript show: '         / ';  show:' \ '; cr.	Transcript show: '        '; show: node1 leftKid rootLabel; show: '  '.	Transcript show: node1 rightKid rootLabel; cr.	Transcript show: '       / '; cr.	Transcript show: '     '; show: node2 leftKid rootLabel; cr.	Transcript show: '    / '; cr.	Transcript show: '   '; show: node4 leftKid rootLabel; cr.	Transcript show: '     \ '; cr.	Transcript show: '       '; show: node5 rightKid rootLabel; cr.	Transcript show: '        \ '; cr.	Transcript show: '         '; show: node6 rightKid rootLabel; cr.	Transcript show: '--------------- TRAVERSAL #2 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr.	Transcript show: traverse next rootLabel; cr. 		"TODO: ADD A TEST TREE #3 HERE!!"	! !!InorderTest class methodsFor: 'testScripts' stamp: 'KF 3/6/2017 17:04'!testRecursive	"test method for inorder traversal of BinTree via recursion"	"README: to call this method, type 'InorderTest testRecursive' into workspace" 	|node1 node2 node3 node4 node5 node6 node7 traverse|		Transcript clear.		" Test tree #1" 	Transcript show: '------------- TREE #1 (complete, depth=3)--------------'; cr.	node1 _ BinTree new: 'A'.	node2 _ BinTree new: 'B'.	node3 _ BinTree new: 'C'.	node4 _ BinTree new: 'D'.	node5 _ BinTree new: 'E'.	node6 _ BinTree new: 'F'.	node7 _ BinTree new: 'G'.	node1 addLeftKid: node2.	node1 addRightKid: node3.	node2 addLeftKid: node4.	node2 addRightKid: node5.	node3 addLeftKid: node6.	node3 addRightKid: node7.	Transcript show: '     '.	Transcript show: node1 rootLabel; cr.	Transcript show: '    / ';  show:' \ '; cr.	Transcript show: '   '; show: node1 leftKid rootLabel; show: ' '.	Transcript show: '  '.	Transcript show: node1 rightKid rootLabel; cr.	Transcript show: ' / ';  show:' \ '; show: ' / ';  show:' \ '; cr.	Transcript show: node2 leftKid rootLabel.	Transcript show: '  '.	Transcript show: node2 rightKid rootLabel.	Transcript show: '  '.	Transcript show: node3 leftKid rootLabel.	Transcript show: '  '.	Transcript show: node3 rightKid rootLabel; cr.	Transcript show: '--------------- TRAVERSAL #1 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	traverse traverseRecursively: node1.		" Test tree #2" 	Transcript show: '------------- TREE #2 (skewed, depth=6)--------------'; cr.	node1 _ BinTree new: 'A'.	node2 _ BinTree new: 'B'.	node3 _ BinTree new: 'C'.	node4 _ BinTree new: 'D'.	node5 _ BinTree new: 'E'.	node6 _ BinTree new: 'F'.	node7 _ BinTree new: 'G'.	node1 addLeftKid: node2.	node1 addRightKid: node3.	node2 addLeftKid: node4.	node4 addLeftKid: node5.	node5 addRightKid: node6.	node6 addRightKid: node7.	Transcript show: '          '.	Transcript show: node1 rootLabel; cr.	Transcript show: '         / ';  show:' \ '; cr.	Transcript show: '        '; show: node1 leftKid rootLabel; show: '  '.	Transcript show: node1 rightKid rootLabel; cr.	Transcript show: '       / '; cr.	Transcript show: '     '; show: node2 leftKid rootLabel; cr.	Transcript show: '    / '; cr.	Transcript show: '   '; show: node4 leftKid rootLabel; cr.	Transcript show: '     \ '; cr.	Transcript show: '       '; show: node5 rightKid rootLabel; cr.	Transcript show: '        \ '; cr.	Transcript show: '         '; show: node6 rightKid rootLabel; cr.	Transcript show: '--------------- TRAVERSAL #2 -----------------------------'; cr.	traverse _ InorderTraversal new: node1.	traverse traverseRecursively: node1.		"TODO: ADD A TEST TREE #3 HERE!!"	! !Object subclass: #InorderTraversal	instanceVariableNames: 'rootNode currentNode visitStack'	classVariableNames: ''	poolDictionaries: ''	category: 'TraversableTree'!!InorderTraversal methodsFor: 'getters' stamp: 'FL 3/4/2017 16:34'!getCurrentNode	"comment stating purpose of message"		^currentNode! !!InorderTraversal methodsFor: 'getters' stamp: 'FL 3/4/2017 16:46'!getRoot	"comment stating purpose of message"		^rootNode! !!InorderTraversal methodsFor: 'getters' stamp: 'FL 3/4/2017 22:10'!getVisitStack	"returns the stack of visited nodes"		^visitStack! !!InorderTraversal methodsFor: 'setters' stamp: 'FL 3/4/2017 17:10'!setCurrentNode: node	"comment stating purpose of message"		currentNode _ node.! !!InorderTraversal methodsFor: 'setters' stamp: 'FL 3/4/2017 16:46'!setRoot: root	"comment stating purpose of message"		rootNode _ root.! !!InorderTraversal methodsFor: 'IterativeTraversal' stamp: 'FL 3/4/2017 17:29'!first	"Returns the first/root node"		^rootNode! !!InorderTraversal methodsFor: 'IterativeTraversal' stamp: 'FL 3/5/2017 13:30'!next	"gets the next tree node based on inorder traversal"	| nextNode |	nextNode := currentNode.		"check if entire tree has been searched"	(currentNode isNil) ifTrue: [^nil].		"if current node is a leaf, return it"	(self isLeaf: currentNode) ifTrue: [		(visitStack isEmpty) ifTrue: [			currentNode := nil.		]		ifFalse: [			currentNode := visitStack top.		].			^nextNode	].	"if current node is a visited parent node, return it"	(visitStack isEmpty not) 		ifTrue: [ 			(currentNode == visitStack top) ifTrue: [						visitStack pop.				"make sure there is a right subtree to search or else go back to parent"				(currentNode rightKid isNil not) 					ifTrue: [						currentNode := currentNode rightKid.					]					ifFalse: [						(visitStack isEmpty not) 							ifTrue: [								currentNode := visitStack top.							]							"we found last leaf"							ifFalse: [								currentNode := nil.							].					].								^nextNode.			]		].			"store visited node"	visitStack push: nextNode.	"get the leftest most node"	[nextNode leftKid isNil not] whileTrue: [ nextNode := nextNode leftKid. visitStack push: nextNode].		"if is leaf, return it"	(self isLeaf: nextNode)		ifTrue: [			visitStack pop. "pop off the node to be returned"			currentNode := visitStack top. "start next search at the parent"			^nextNode.		]		ifFalse: [			"check if has right subtree"			(nextNode rightKid isNil not) ifTrue: [				currentNode := nextNode rightKid.			].						visitStack pop.			^nextNode.		].			! !!InorderTraversal methodsFor: 'IterativeTraversal' stamp: 'FL 3/4/2017 18:58'!traverse: node	"traverses down a node's children"	| isLeaf nextNode |	isLeaf := (node leftKid isNil) & ( node rightKid isNil).	isLeaf 		ifTrue: [nextNode := nil]		ifFalse: [		"check left kid"		(node leftKid isNil not) 			ifTrue: [self traverse: node leftKid].		"check right kid"		(node rightKid isNil not)			ifTrue: [nextNode := node rightKid].		].		^nextNode! !!InorderTraversal methodsFor: 'helper' stamp: 'FL 3/4/2017 21:51'!getLeftestLeaf: node	"returns the left most node"	| leftestNode nextNode|	[node isNil] ifTrue: [^nil].	nextNode := node.	"traverse until we find the leftest most leaf"	[nextNode leftKid isNil not] WhileTrue: [ nextNode := nextNode leftKid].	leftestNode := nextNode.		^leftestNode	! !!InorderTraversal methodsFor: 'helper' stamp: 'FL 3/4/2017 22:39'!init	"initializes the visit stack"		visitStack := Stack new.! !!InorderTraversal methodsFor: 'helper' stamp: 'FL 3/4/2017 21:30'!isLeaf: node	"checks if the node is a leaf"	| isLeaf |		(node isNil) ifTrue: [^nil].		isLeaf := (node leftKid isNil) & ( node rightKid isNil).		^isLeaf! !!InorderTraversal methodsFor: 'RecursiveTraversal' stamp: 'KF 3/6/2017 16:30'!traverseRecursively: tree	"the recursive way for inorder traversal"	| left right|	left _ tree leftKid.	right _ tree rightKid.		(left notNil) ifTrue: [ self traverseRecursively: left ].	Transcript show: tree rootLabel; cr.	(right notNil) ifTrue: [ self traverseRecursively: right ].	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InorderTraversal class	instanceVariableNames: ''!!InorderTraversal class methodsFor: 'Creation' stamp: 'KF 3/6/2017 15:47'!new: root	"comment stating purpose of message"	| instance |	instance := super new.	instance setRoot: root.	instance setCurrentNode: root.	instance init.	^ instance! !